{"meta":{"title":"蒋冲","subtitle":null,"description":null,"author":"Zi Yi","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-03-25T14:02:47.423Z","updated":"2018-03-25T14:02:47.423Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-25T14:02:47.425Z","updated":"2018-03-25T14:02:47.425Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-03-25T14:02:47.424Z","updated":"2018-03-25T14:02:47.424Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue基础了解","slug":"Vue基础了解","date":"2018-04-10T13:37:25.000Z","updated":"2018-04-10T15:00:58.160Z","comments":true,"path":"2018/04/10/Vue基础了解/","link":"","permalink":"http://yoursite.com/2018/04/10/Vue基础了解/","excerpt":"Vue入门介绍Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。","text":"Vue入门介绍Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 vue什么是双向数据绑定Vue框架很核心的功能就是双向的数据绑定。 双向是指：HTML标签数据 绑定到 Vue对象，另外反方向数据也是绑定的。通俗点说就是，Vue对象的改变会直接影响到HTML的标签的变化，而且标签的变化也会反过来影响Vue对象的属性的变化。 由Dom开发的主导时代更变为数据驱动开发时代。 之前Dom驱动的开发方式尤其是以jQuery为主的开发时代，都是dom变化后，触发js事件，然后在事件中通过js代码取得标签的变化，再跟后台进行交互，然后根据后台返回的结果再更新HTML标签，异常的繁琐。有了Vue这种双向绑定，让开发人员只需要关心json数据的变化即可，Vue自动映射到HTML上，而且HTML的变化也会映射回js对象上 Vue绑定文本数据绑定最常见的形式就是使用 Mustache语法（双大括号）的文本插值 绑定的数据可以使用javaScript表达式对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。 12345678910&lt;div&gt;Message: &#123;&#123; msg + ' - ' + name &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 msg: 'Hello', // message 自定义的数据 name: 'world' // name自定义的属性，vue可以多个自定义属性，属性类型也可是复杂类型 &#125; &#125;);&lt;/script&gt; 结果：Hello-world vue还支持表达式中的计算、函数处理。123&lt;div&gt;Message: &#123;&#123; true ? '123' : '456' &#125;&#125;&lt;/div&gt;&lt;p&gt;&lt;div&gt;Message: &#123;&#123; num*5 &#125;&#125;&lt;/div&gt; Vue属性绑定Vue中不能直接使用语法进行绑定html的标签，而是用它特有的v-bind指令123&lt;标签 v-bind:属性名=\"绑定vue对象data里的属性名\"&gt;&lt;/标签&gt;例如：&lt;div v-bind:attr=\"name\"&gt;&lt;/div&gt; v-bind使用非常频繁，所以Vue提供了简单的写法，可以去掉v-bind直接使用:即可 Vue输出html 由于Vue对于输出绑定的内容做了提前encode，保障在绑定到页面上显示的时候不至于被xss攻击。但某些场景下，我们确保后台数据是安全的，那么我们就要在网页中显示原生的HTML标签。Vue提供了v-html指令。 123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"tagHtml\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 tagHtml: '&lt;p&gt;这里是p标签里的内容&lt;/p&gt;' &#125; &#125;);&lt;/script&gt; 样式的绑定绑定样式对象经常我们需要对样式进行切换，比如：div的显示和隐藏1234567891011121314151617&lt;style&gt; .active&#123; background-color:red; &#125;&lt;/style&gt;代码：&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;解释：当 isActive为 true时，div就会具有了active样式类，如果isActive为false，那么div就去掉active样式类。&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 isActive: true &#125; &#125;);&lt;/script&gt; 混合普通的HTML标签样式类及绑定样式对象v-bind:class指令可以和普通class共存;最后它们会合并到一个class里12345678910111213&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, hasError: false &#125; &#125;);&lt;/script&gt; 合并后：1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 绑定data中样式对象直接在html属性中的双引号内写对象,没有智能提示，很容易写错.Vue可以让我们直接把绑定的class字符串指向data的一个对象 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"classObject\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; classObject: &#123; active: true, 'text-danger': false &#125; &#125; &#125;);&lt;/script&gt; 得到结果： 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 内联样式绑定内联样式的绑定，非常类似于样式类的操作。v-bind:style 的对象语法十分直观——看着非常像CSS ，其实它是一个 JavaScript对象。 CSS属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）。 123456789101112131415&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"&#123;fontSize: size + 'px', backgroundColor: bgcolor, width: width&#125;\"&gt; vue 入门系列教程 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; size: 19, width: 200, bgcolor: 'red' &#125; &#125;); &lt;/script&gt; 自动添加前缀当 v-bind:style 使用需要特定前缀的CSS属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Promise","slug":"Promise","date":"2018-04-09T14:52:43.000Z","updated":"2018-04-10T13:48:32.681Z","comments":true,"path":"2018/04/09/Promise/","link":"","permalink":"http://yoursite.com/2018/04/09/Promise/","excerpt":"Promise Promise基本认识 ECMAScript6(ES2015)的发布，Promise 被列为正式规范，为 ES6 中最重要的特性之一。","text":"Promise Promise基本认识 ECMAScript6(ES2015)的发布，Promise 被列为正式规范，为 ES6 中最重要的特性之一。 前言ES6中原生已经对它加已支持https://caniuse.com/中搜索一下Promise,主流的浏览器都已经支持。但是低版本的浏览器我们可以使用es6-promise这个polyfill库来加以兼容。 Promise是什么？ECMAScript6(ES2015)的发布，Promise 被列为正式规范，为 ES6 中最重要的特性之一。 Promise是异步编程的一种解决方案，它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败 当Promise的状态由pending转变为resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字promise-承诺的由来 Promise的出现，原本是为了解决回调地狱的问题，讲Promise时，都会以Ajax请求为例： ajax原写法： 12345678910111213141516function ajax(method,url,successFun,failFun)&#123; var xml = new XMLHttpRequest(); xml.open(method,url); xml.send(); xml.onload = function()&#123; if(this.status == 200)&#123; successFun(this.response); &#125;else&#123; failFun(this.statusText); &#125; &#125; xml.error = function()&#123; failFun(this.statusText) &#125;&#125; Promise写法： 1234567891011121314151617181920212223function ajax(method,url)&#123; var promise = new Promise(function(resolve,reject)&#123; var xml = new XMLHttpRequest(); xml.open(method,url); xml.send(); xml.onload= function()&#123; if(this.status == 200)&#123; resolve(this.response); &#125;else&#123; reject(this.statusText); &#125; &#125; xml.error = function()&#123; reject(this.statusText); &#125; &#125;) return promise&#125;//调用：ajax(\"get\",\"https://.....\").then(successFun,failFun)//或ajax(\"get\",\"https://.....\").then(successFun).catch(failFun) 我们把异步中使用回调函数的场景改为了.then()、.catch()等函数链式调用的方式。基于promise我们可以把复杂的异步回调处理方式进行模块化 Promise的原理promise它内部有三个状态，分别是pending，fulfilled和ejected。 状态 Promise的初始状态是 Pending ，状态只能被转换为（Resolved）Fulfilled或Rejected，状态的转换不可逆。 then必须有 then方法，接收两个可选函数参数onFulfilled、onRejected，then方法必须返回一个新的Promise对象，为了保证then中回调的执行顺序，回调必须使用异步执行。 兼容 不同的 Promise的实现必须可以互相调用 除了串行执行若干异步任务外，Promise还可以并行执行异步任务: 从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下： 123var pro1 = new Promise(function(resolve,reject)&#123; setTimeout(function()&#123;&#125;,100) &#125;);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"transform遇到问题","slug":"transform中所遇到问题","date":"2018-04-08T15:26:04.000Z","updated":"2018-04-08T15:33:52.710Z","comments":true,"path":"2018/04/08/transform中所遇到问题/","link":"","permalink":"http://yoursite.com/2018/04/08/transform中所遇到问题/","excerpt":"scale()属性使用问题 transform:scale()缩放导致文字抖动问题 解决办法：在抖动区域元素上添加:transform:translateZ(0);","text":"scale()属性使用问题 transform:scale()缩放导致文字抖动问题 解决办法：在抖动区域元素上添加:transform:translateZ(0); translate()作位移 transform：translate代替position中的left做位移好处 left是布局类的样式，这个样式的变化会导致重排（reflow/relayout），所谓重排即指对这些节点以及受这些节点影响的其它节点，进行CSS计算-&gt;布局-&gt;重绘过程，这个过程的前2步是消耗大量资源的 translate同样改变样式，这个样式的变化会导致重绘（repaint），不会进行CSS计算和布局这2个性能大户，所以我们认为translate性能上好于left","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"默认滚动条样式修改","slug":"默认滚动条样式修改","date":"2018-04-08T15:11:22.000Z","updated":"2018-04-08T15:20:05.610Z","comments":true,"path":"2018/04/08/默认滚动条样式修改/","link":"","permalink":"http://yoursite.com/2018/04/08/默认滚动条样式修改/","excerpt":"滚动条默认样式修改 适用webkit内核","text":"滚动条默认样式修改 适用webkit内核 1234567&lt;div id=\"wrap\"&gt; &lt;ul class=\"detailRight\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; ..... &lt;/ul&gt;&lt;/div&gt; 123456789101112131415.detailRight::-webkit-scrollbar &#123;/*滚动条整体样式*/ width: 10px; /*高宽分别对应横竖滚动条的尺寸*/ height: 1px;&#125;.detailRight::-webkit-scrollbar-thumb &#123;/*滚动条里面小方块*/ border-radius: 10px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background: #263347;&#125;.detailRight::-webkit-scrollbar-track &#123;/*滚动条里面轨道*/ -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2); border-radius: 10px; background: transparent;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"vue子父组件属性之间的操作","slug":"父组件改变子组件属性","date":"2018-04-01T16:00:00.000Z","updated":"2018-04-08T14:35:41.782Z","comments":true,"path":"2018/04/02/父组件改变子组件属性/","link":"","permalink":"http://yoursite.com/2018/04/02/父组件改变子组件属性/","excerpt":"属性改变 父组件事件触发改变子组件属性值 在Vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。 父组件创建一个改变事件","text":"属性改变 父组件事件触发改变子组件属性值 在Vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。 父组件创建一个改变事件 1234567891011121314151617//data export default &#123; data() &#123; return &#123; msg: '信息', isCurr: &#123; a:1, b:2 &#125;, methods:&#123; butFun:function()&#123; this.isCurr.a = 2; &#125; &#125; &#125; &#125; &#125; 123&lt;div class='componmentBox'&gt; &lt;information v-bind:defined='isCurr'&gt;&lt;/information&gt;&lt;/div&gt; 这里的defined是自己定义的名字，添加在子组件props里面，需要注意是：如果是驼峰名，例如：nameShow，props里面是：props:[&quot;nameShow&quot;]，父组件要添加属性是v-bind:name-show=&quot;&quot;;要添加“-”。 子组件如何获取改变的事件 12345678910111213//子组件添加： export default &#123; data() &#123; return &#123; props:[\"defined\"], watch:&#123; defined:function(val)&#123; //这里面的val就是defined的key值 &#125; &#125; &#125; &#125;&#125; 子组件改变父组件的值 子组件educationdate 1this.$emit(\"backChangeFalse\"); 需要在什么时候改变父组件属性时，调用this.$emit() 父组件 要在父组件调用组件的元素上添加一个事件方法：v-on:子级自定义=&quot;&quot; 根据父组件的方法来改变父组件上的属性 123&lt;div class='componmentBox' &gt; &lt;educationdate v-on:backChangeFalse='backChangeFalse'&gt;&lt;/educationdate&gt;&lt;/div&gt; 123456789101112export default &#123; data() &#123; return &#123; back:true; methods:&#123; backChangeFalse:function()&#123; this.back = false; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"三栏布局","slug":"七种三栏布局","date":"2018-03-24T14:13:35.000Z","updated":"2018-04-08T15:21:31.630Z","comments":true,"path":"2018/03/24/七种三栏布局/","link":"","permalink":"http://yoursite.com/2018/03/24/七种三栏布局/","excerpt":"三栏布局1. 流体布局","text":"三栏布局1. 流体布局 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;style&gt; .left&#123; float:left; width:100px; height:200PX; background-color:red; &#125; .right&#123; float:rigth; width:200px; height:200px; background-color:blue; &#125; .main&#123; margin-right:120px; margin-left:220px; height:200px; background-color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='container'&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. BFC 三栏布局BFC规则 有这样的描述：BFC区域，不会与浮动元素重叠，利用这一点实现。 Block formatting context (BFC)块级格式化上下文,bfc三栏布局的主体部分会后加载 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang = \"en\"&gt;&lt;head&gt; &lt;style&gt; .left&#123; float:left; width:100px; height:200px; margin-right:20px; background-color:red; &#125; .right&#123; float:right; width:200px; height:200px; margin-left:20px; background-color:blue; &#125; .main&#123; height:200px; overflow:hidden; background-color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 缺点跟方法一类似，主要内容模块无法最先加载，当页面中内容较多时会影响用户体验。因此为了解决这个问题，有了下面要介绍的布局方案双飞翼布局。 3. 双飞翼布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .content&#123; float:left; width:100%; &#125; .main&#123; height:200px; margin-left:110px; margin-right:220px; background-color:green; &#125; //清除浮动 .main::after&#123; display:block; content:\"\"; clear:both; font-size:0; height:0; zoom:1; &#125; .left&#123; float:left; height:200px; width:100px; margin-left:-100%; background-color:red; &#125; .right&#123; width:200px; height:200px; float:right; margin-left:-200px; background-color:blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用的是浮动元素 margin 负值的应用，感兴趣的同学可以上网搜搜原理。 主体内容可以优先加载，HTML 代码结构稍微复杂点。 4. 圣杯布局跟双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; .container &#123; margin-left: 120px; margin-right: 220px; &#125; .main &#123; float: left; width: 100%; height: 300px; background-color: red; &#125; .left &#123; float: left; width: 100px; height: 300px; margin-left: -100%; position: relative; left: -120px; background-color: blue; &#125; .right &#123; float: left; width: 200px; height: 300px; margin-left: -200px; position: relative; right: -220px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.Flex 布局flex属性； 主体设置flex-grow:1;占的份数，加上order:-1值越小越靠前排 简单实用，未来的趋势，需要考虑浏览器的兼容性。1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: flex; &#125; .main &#123; flex-grow: 1; height: 300px; background-color: red; &#125; .left &#123; order: -1; flex: 0 1 200px; margin-right: 20px; height: 300px; background-color: blue; &#125; .right &#123; flex: 0 1 100px; margin-left: 20px; height: 300px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. Table 布局父级设置display:table属性，内部元素设置display:table-cell，按照位置从左到右排列。 缺点：无法设置栏间距12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: table; width: 100%; &#125; .left, .main, .right &#123; display: table-cell; &#125; .left &#123; width: 200px; height: 300px; background-color: red; &#125; .main &#123; background-color: blue; &#125; .right &#123; width: 100px; height: 300px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位三栏布局采用了父级绝对定位，主题内容给个左右固定值得margin，左右采用相对定位，给固定宽度。 特点：简单实用，并且主要内容可以优先加载。123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;style&gt; .container &#123; position: relative; &#125; .main &#123; height: 400px; margin: 0 120px; background-color: green; &#125; .left &#123; position: absolute; width: 100px; height: 300px; left: 0; top: 0; background-color: red; &#125; .right &#123; position: absolute; width: 100px; height: 300px; background-color: blue; right: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"source","slug":"source","permalink":"http://yoursite.com/categories/source/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"新页面","slug":"新页面","date":"2018-03-24T13:13:35.000Z","updated":"2018-03-24T13:46:13.542Z","comments":true,"path":"2018/03/24/新页面/","link":"","permalink":"http://yoursite.com/2018/03/24/新页面/","excerpt":"","text":"文章1var html = document.getElementById(\"#wrap\") 第二篇","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-23T14:05:18.193Z","updated":"2018-03-23T14:05:18.193Z","comments":true,"path":"2018/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}